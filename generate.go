package main

import (
	"fmt"
	"github.com/jawher/mow.cli"
	"github.com/zpatrick/go-parser"
	"log"
	"os"
	"text/template"
)

type Specs struct {
	Path     *string
	Struct   *string
	Package  *string
	Template *string
}

type TemplateContext struct {
	Package    string
	Type       string
	Name       string
	PrimaryKey string
	TypeImport string
}

func main() {
	Specs := Specs{}
	app := cli.App("sdata", "Data persistance made simple")
	Specs.Path = app.StringArg("PATH", "", "Path to the source file")
	Specs.Struct = app.StringArg("STRUCT", "", "Name of the source struct")
	Specs.Package = app.StringOpt("p package", "", "Package name for the destination file")
	Specs.Template = app.StringOpt("t template", "", "Path to the template file")

	app.Spec = "PATH STRUCT [--package] [--template]"

	app.Action = func() {
		if err := Generate(Specs); err != nil {
			log.Fatal(err)
			os.Exit(1)
		}
	}

	app.Run(os.Args)
}

func Generate(specs Specs) error {
	goFile, err := parser.ParseFile(*specs.Path)
	if err != nil {
		return err
	}

	if len(goFile.Structs) == 0 {
		return fmt.Errorf("No struct definitions found in source file")
	}

	if specs.Package == nil {
		specs.Package = &goFile.Package
	}

	var target *parser.GoStruct
	for _, goStruct := range goFile.Structs {
		if goStruct.Name == *specs.Struct {
			target = goStruct
			break
		}
	}

	if target == nil {
		return fmt.Errorf("No struct named '%s' found in input file", *specs.Struct)
	}

	primaryKey, err := findPrimaryKey(target)
	if err != nil {
		return err
	}

	return writeDataFile(specs, target, primaryKey.Name)
}

func findPrimaryKey(target *parser.GoStruct) (*parser.GoField, error) {
	fields := []*parser.GoField{}
	for _, field := range target.Fields {
		if field.Tag == nil {
			continue
		}

		if tag := field.Tag.Get("data"); tag == "primary_key" {
			if field.Type != "string" {
				return nil, fmt.Errorf("The primary_key field must be of type 'string'")
			}

			fields = append(fields, field)
		}
	}

	rawField := "`data:\"primary_key\"`"
	if len(fields) == 0 {
		return nil, fmt.Errorf("No fields tagged with %s in target struct", rawField)
	} else if len(fields) > 1 {
		return nil, fmt.Errorf("Mutiple fields tagged with %s in target struct", rawField)
	}

	return fields[0], nil
}

func writeDataFile(specs Specs, target *parser.GoStruct, primaryKey string) error {
	var parser func() (*template.Template, error)

	if *specs.Template == "" {
		parser = func() (*template.Template, error) { return template.New("").Parse(DefaultStoreTemplate) }
	} else {
		parser = func() (*template.Template, error) { return template.ParseFiles(*specs.Template) }
	}

	tmpl, err := parser()
	if err != nil {
		return err
	}

	outputPackage := target.File.Package
	if *specs.Package != "" {
		outputPackage = *specs.Package
	}

	typeImport := ""
	structType := target.Name

	if outputPackage != target.File.Package {
		structType = fmt.Sprintf("%s.%s", target.File.Package, target.Name)

		path, err := target.File.ImportPath()
		if err != nil {
			return err
		}

		typeImport = path
	}

	context := TemplateContext{
		Package:    outputPackage,
		Type:       structType,
		Name:       target.Name,
		PrimaryKey: primaryKey,
		TypeImport: typeImport,
	}

	if err := tmpl.Execute(os.Stdout, context); err != nil {
		return err
	}

	return nil
}

const DefaultStoreTemplate = `package {{ .Package }}

// Automatically generated by go-sdata. DO NOT EDIT!

import (
    "encoding/json"
    "github.com/zpatrick/go-sdata/container"
    {{ if .TypeImport }} "{{ .TypeImport }}" {{ end }}
)

type {{ .Name }}Store struct {
    container container.Container
    table     string
}

func New{{ .Name }}Store(container container.Container) *{{ .Name }}Store {
    return &{{ .Name }}Store{
        container: container,
        table:     "{{ .Type }}",
    }
}

func (this *{{ .Name }}Store) Init() error {
    return this.container.Init(this.table)
}

type {{ .Name }}StoreInsert struct {
    *{{ .Name }}Store
    data *{{ .Type }}
}

func (this *{{ .Name }}Store) Insert(data *{{ .Type }}) *{{ .Name }}StoreInsert {
    return &{{ .Name }}StoreInsert{
        {{ .Name }}Store: this,
        data:       data,
    }
}

func (this *{{ .Name }}StoreInsert) Execute() error {
    bytes, err := json.Marshal(this.data)
    if err != nil {
        return err
    }

    return this.container.Insert(this.table, this.data.ID, bytes)
}

type {{ .Name }}StoreSelectAll struct {
    *{{ .Name }}Store
    filter {{ .Name }}Filter
}

func (this *{{ .Name }}Store) SelectAll() *{{ .Name }}StoreSelectAll {
    return &{{ .Name }}StoreSelectAll{
        {{ .Name }}Store: this,
    }
}

type {{ .Name }}Filter func(*{{ .Type }}) bool

func (this *{{ .Name }}StoreSelectAll) Where(filter {{ .Name }}Filter) *{{ .Name }}StoreSelectAll {
    this.filter = filter
    return this
}

func (this *{{ .Name }}StoreSelectAll) Execute() ([]*{{ .Type }}, error) {
    data, err :=  this.container.SelectAll(this.table)
    if err != nil {
        return nil, err
    }

    results := []*{{ .Type }}{}
    for _, d := range data {
        var value *{{ .Type }}

        if err := json.Unmarshal(d, &value); err != nil {
            return nil, err
        }

		if this.filter == nil || this.filter(value) {
			results = append(results, value)
		}
    }

    return results, nil
}

type {{ .Name }}StoreSelectFirst struct {
    *{{ .Name }}StoreSelectAll
}

func (this *{{ .Name }}StoreSelectAll) FirstOrNil() *{{ .Name }}StoreSelectFirst {
    return &{{ .Name }}StoreSelectAll{
        {{ .Name }}StoreSelectAll: this,
    }
}

func (this *{{ .Name }}StoreSelectFirst) Execute() (*{{ .Type }}, error) {
    results, err := this.{{ .Name }}StoreSelectAll.Execute()
    if err != nil {
        return nil, err
    }

    if len(results) > 0 {
        return results[0], nil
    }

    return nil, nil
}

type {{ .Name }}StoreDelete struct {
    *{{ .Name }}Store
    key string
}

func (this *{{ .Name }}Store) Delete(key string) *{{ .Name }}StoreDelete {
    return &{{ .Name }}StoreDelete{
        {{ .Name }}Store: this,
        key:        key,
    }
}

func (this *{{ .Name }}StoreDelete) Execute() (bool, error) {
    return this.container.Delete(this.table, this.key)
}
`
